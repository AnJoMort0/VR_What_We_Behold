<!DOCTYPE html>
<html>
  <head>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <link   rel="stylesheet" href="css/game.css">
    <script src="js/textStrings.js"></script>

    <script>
      // GENERAL VALUES
      const PEEP_SPAWN_COUNT    = 12;
      const PEEP_SPAWN_RADIUS   = 8;
      const PEEP_DEFAULT_SPEED  = 0.015;

      /**
       * PHOTO-CAPTURE COMPONENT
       * Grabs a snippet of the canva in GPU and shows it on click
       * heavily chatGPT assisted, but after lots of guidance and research on StackOverflow to finally come to this https://stackoverflow.com/questions/19183180/how-to-save-an-image-to-localstorage-and-display-it-on-the-next-page
       */
      AFRAME.registerComponent('photo-capture', {
        init: function () {
          const sceneEl    = this.el.sceneEl;
          const renderer   = sceneEl.renderer;
          const camera     = sceneEl.camera;
          const frameImg   = document.getElementById('cameraOverlay');

          // 1) Prepare a small GPU render‐target at overlay size
          const rtW = Math.floor(window.innerWidth  * 0.3);
          const rtH = Math.floor(window.innerHeight * 0.5);
          const renderTarget = new THREE.WebGLRenderTarget(rtW, rtH);

          // 2) On click: crop, render, read back & stamp into an HTML <img>
          window.addEventListener('click', () => {
            // a) Measure CSS overlay bounds & convert to WebGL pixels
            const rect    = frameImg.getBoundingClientRect();
            const dpr     = window.devicePixelRatio || 1;
            const fullW   = renderer.domElement.width;
            const fullH   = renderer.domElement.height;
            const offsetX = rect.left   * dpr;
            const offsetY = rect.top    * dpr;
            const cropW   = rect.width  * dpr;
            const cropH   = rect.height * dpr;
            const vY      = fullH - offsetY - cropH;

            // b) Tell the camera to only render that sub-frustum
            camera.setViewOffset(fullW, fullH, offsetX, vY, cropW, cropH);

            // c) Render into our small render-target (all on GPU)
            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            renderer.render(sceneEl.object3D, camera);
            renderer.setRenderTarget(null);

            // d) Restore full view
            camera.clearViewOffset();

            // e) Read pixels back into CPU memory (RGBA)
            const w = renderTarget.width;
            const h = renderTarget.height;
            const buffer = new Uint8Array(4 * w * h);
            renderer.readRenderTargetPixels(renderTarget, 0, 0, w, h, buffer);

            // f) Bake into an off-screen <canvas>
            const tmp     = document.createElement('canvas');
            tmp.width     = w;
            tmp.height    = h;
            const ctx     = tmp.getContext('2d');
            const imgData = ctx.createImageData(w, h);
            imgData.data.set(buffer);
            ctx.putImageData(imgData, 0, 0);

            // g) Create or update the HTML <img> on top
            let snap = document.getElementById('photoOverlay');
            if (!snap) {
              snap = document.createElement('img');
              snap.id = 'photoOverlay';
              document.body.appendChild(snap);
            }
            snap.src = tmp.toDataURL('image/png');
          });
        }
      });

      /**
       * CAMERA-TRACKER COMPONENT
       * Projects every peep into screen-space and logs those whose coordinates fall inside the cameraOverlay element.
       * Heavily chatGPT assisted because I was propper stuck.
       */
       AFRAME.registerComponent('camera-tracker', {
        init: function () {
          // Grab Three.js camera and the overlay DOM element
          this.threeCam = this.el.sceneEl.camera;
          this.overlay  = document.getElementById('cameraOverlay');
        },
        tick: function () {
          if (!this.threeCam || !this.overlay) return;

          // Get overlay pixel bounds
          const rect = this.overlay.getBoundingClientRect();
          // Find all peeps by data attribute
          const peeps = this.el.sceneEl.querySelectorAll('[data-peep-type]');
          peeps.forEach(peep => {
            // 1) World position
            const worldPos = new THREE.Vector3();
            peep.object3D.getWorldPosition(worldPos);
            // 2) Project to normalized device coords
            worldPos.project(this.threeCam);
            // 3) Convert to screen pixels
            const x = (worldPos.x + 1) / 2 * window.innerWidth;
            const y = (1 - worldPos.y) / 2 * window.innerHeight;
            // 4) If inside overlay, log it
            if (
              x >= rect.left &&
              x <= rect.right &&
              y >= rect.top &&
              y <= rect.bottom
            ) {
              console.log(
                `Peep in overlay → id=${peep.id}, type=${peep.dataset.peepType}`
              );
            }
          });
        }
      });

      /**
       * PEEP-MOVER COMPONENT
       * Moves the peep randomly in the XZ plane, bounces back when leaving radius, and flips entity horizontally based on movement direction.
       * Moderately chatGPT assisted.
       */
      AFRAME.registerComponent('peep-mover', {
        schema: {
          speed:  { type: 'number', default: PEEP_DEFAULT_SPEED },
          radius: { type: 'number', default: PEEP_SPAWN_RADIUS }
        },
        init: function () {
          // Initialize a random movement direction
          this.direction = Math.random() * 2 * Math.PI;
        },
        tick: function (time, delta) {
          const pos     = this.el.object3D.position;
          const prevPos = pos.clone(); // this is needed to make sure peeps face the correct direction
          // Move in direction, scaled by delta
          const moveAmt = this.data.speed * (delta / 16);
          const dx      = Math.cos(this.direction) * moveAmt;
          const dz      = Math.sin(this.direction) * moveAmt;
          pos.x += dx;
          pos.z += dz;

          // Bouce at boundaries
          const r = this.data.radius;
          if (pos.x > r) {
            pos.x = r;
            this.direction = Math.PI - this.direction;
          }
          if (pos.x < -r) {
            pos.x = -r;
            this.direction = Math.PI - this.direction;
          }
          if (pos.z > r) {
            pos.z = r;
            this.direction = -this.direction;
          }
          if (pos.z < -r) {
            pos.z = -r;
            this.direction = -this.direction;
          }

          this.el.object3D.position.copy(pos);

          // — NEW FLIP LOGIC, heavily chatGPT assisted — project both positions to camera NDC
          const cam     = this.el.sceneEl.camera;
          const ndcPrev = prevPos.clone().project(cam);
          const ndcCurr = pos.clone().project(cam);
          // if it moved right on screen, keep scale=1; otherwise flip
          let flip;
          if (ndcCurr.x > ndcPrev.x) {
              flip = 1;
          } else {
              flip = -1;
          }
          this.el.setAttribute('scale', `${flip} 1 1`);
        }
      });

      /**
       * BILLBOARD COMPONENT
       * Rotates the entity around the Y axis so its front face always faces the camera, keeping the sprite upright on the XZ plane.
       * Heavily chatGPT assisted, it fixed my 'look-at-y' component that was not working properly
       */
      AFRAME.registerComponent('billboard', {
        tick: function () {
          const camera  = this.el.sceneEl.camera;
          const obj     = this.el.object3D;
          // Get world positions
          const camPos  = new THREE.Vector3();
          camera.getWorldPosition(camPos);
          const pos     = obj.position;

          // Compute angle on XZ plane and set Y rotation
          const dx = camPos.x - obj.position.x;
          const dz = camPos.z - obj.position.z;
          const angle = Math.atan2(dx, dz);
          const deg   = THREE.MathUtils.radToDeg(angle);
          this.el.setAttribute('rotation', { x: 0, y: deg, z: 0 });
        }
      });

      /**
       * NO-FRUSTUM-CULLL COMPONENT
       * Disables frustum culling on the mesh so entities don't vanish when out of view bounds
       * Fully chatGPT generated, I have no idea how this works, that's how it fixed the peeps disappearing out of bounds
       */
       AFRAME.registerComponent('no-frustum-cull', {
          init: function () {
            this.el.addEventListener('loaded', () => {
              this.el.object3D.traverse(node => {
                if (node.isMesh) node.frustumCulled = false;
              });
            });
          }
        });

      /**
       * PEEP-MANAGER COMPONENT
       * Spawns a number of peeps, with tags, id and data-peep-type, and attaches mover + billboard + no-frustum-cull.
       * chatGPT assisted
       */
       AFRAME.registerComponent('peep-manager', {
        schema: {
          count: { type: 'int', default: PEEP_SPAWN_COUNT },
          radius: { type: 'number', default: PEEP_SPAWN_RADIUS },
          assetPrefix: { type: 'string', default: '#' }
        },
        init: function () {
          const half = this.data.count / 2;
          for (let i = 0; i < this.data.count; i++) {
            let type;
            if (i < half) {
              type = 'circle';
            } else {
              type = 'square';
            }

            let spriteId;
            if (type === 'circle') {
              spriteId = 'circleNeutralPeep';
            } else {
              spriteId = 'squareNeutralPeep';
            }

            const peepEl = document.createElement('a-image');

            // Unique ID and type tag, this is used to know what peeps are in front of the camera
            peepEl.setAttribute('id', `peep-${type}-${i}`);
            peepEl.setAttribute('data-peep-type', type);

            // Random XZ within radius, Y = 1
            const angle   = Math.random() * 2 * Math.PI;
            const dist    = Math.random() * this.data.radius;
            const x = dist * Math.cos(angle);
            const z = dist * Math.sin(angle);
            peepEl.setAttribute('position', `${x} 1 ${z}`);
            peepEl.setAttribute('src', this.data.assetPrefix + spriteId);

             // Prevents png invisible parts collision
            peepEl.setAttribute('material', 'transparent: true; alphaTest: 0.01');

            // Add behaviors
            peepEl.setAttribute('billboard', '');
            peepEl.setAttribute(
              'peep-mover',
              `speed: ${0.01 + Math.random() * 0.01}; radius: ${
                this.data.radius
              }`
            );
            peepEl.setAttribute('no-frustum-cull', '');

            this.el.appendChild(peepEl);
          }
        }
      });
    </script>
  </head>

  <body>
    <a-scene fog="type: linear; color: #D3D3D3; near: 20; far: 100">
      <!-- Assets -->
      <a-assets>
        <img id = "ground"            src = "sprites/ground.png" />
        <img id = "circleNeutralPeep" src = "sprites/peeps/placeholder/circle_neutral_peep.png" />
        <img id = "squareNeutralPeep" src = "sprites/peeps/placeholder/square_neutral_peep.png" />
      </a-assets>

      <!-- Player camera -->
      <a-entity
        id        = "playerCamera"
        camera    = "near:0.1; far:500"
        look-controls = "
            pointerLockEnabled:         true;
            magicWindowTrackingEnabled: true;
            mouseEnabled:               true;
            touchEnabled:               true;
            "
        camera-tracker
        photo-capture
        position  = "0 1.6 0"
      ></a-entity>

      <!-- Infinite ground plane -->
      <a-plane
        src       = "#ground"
        rotation  = "-90 0 0"
        width     = "200"
        height    = "200"
        material  = "repeat: 40 40; side: double">
      </a-plane>

      <!-- Sky background -->
      <a-sky color="#D3D3D3"></a-sky>

      <!-- Peep spawner -->
      <a-entity
        id        = "peeps"
        peep-manager
      ></a-entity>
    </a-scene>

    <!-- Camera overlay HUD -->
    <img
      id        = "cameraOverlay"
      src       = "sprites/cam/cam.png"
      alt       = "Camera Overlay should be here"
    />
  </body>
</html>