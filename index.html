<!DOCTYPE html>
<html>
  <head>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="js/textStrings.js"></script>

    <script>
      // GENERAL VALUES
      const PEEP_SPAWN_COUNT    = 12;
      const PEEP_SPAWN_RADIUS   = 8;
      const PEEP_DEFAULT_SPEED  = 0.015;

      AFRAME.registerComponent('debug-toggle', { // chatGPT assisted
        init: function () {
          window.DEBUG = false;

          // peep id labels
          const updateLabels = show => {
            document.querySelectorAll('.debug-label')
              .forEach(el => el.setAttribute('visible', show));
          };

          // Toggle on “D” key
          window.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'd') {
              window.DEBUG = !window.DEBUG;
              updateLabels(window.DEBUG);
              console.log('Debug mode:', window.DEBUG ? 'ON' : 'OFF');
            }
          });

          // Toggle on gamepad D-pad Up (standard button index 12)
          this.upPressed = false;
          this.tick = () => {
            const gps = navigator.getGamepads && navigator.getGamepads();
            if (!gps) return;
            for (const gp of gps) {
              if (!gp || !gp.buttons[12]) continue;
              const btn = gp.buttons[12];
              if (btn.pressed && !this.upPressed) {
                window.DEBUG = !window.DEBUG;
                updateLabels(window.DEBUG);
                console.log('Debug mode:', window.DEBUG ? 'ON' : 'OFF');
                this.upPressed = true;
              } else if (!btn.pressed) {
                this.upPressed = false;
              }
            }
          };
        }
      });

      /**
       * PHOTO-CAPTURE COMPONENT
       * Grabs a snippet of the canva in GPU and shows it on click
       * heavily chatGPT assisted, but after lots of guidance and research on StackOverflow to finally come to this https://stackoverflow.com/questions/19183180/how-to-save-an-image-to-localstorage-and-display-it-on-the-next-page
       */
      AFRAME.registerComponent('photo-capture', {
        init: function () {
          const sceneEl    = this.el.sceneEl;
          const renderer   = sceneEl.renderer;
          // Grab the *entity* camera (always the monoscopic one), not the scene’s XR ArrayCamera.
          const cameraEl = this.el.getObject3D('camera');

          const finderFrameEl = sceneEl.querySelector('#finderFrame');
          const photoPlaneEl  = sceneEl.querySelector('#photoPlane');

          // Compute RT size so its aspect matches the plane's
          const pw = parseFloat(photoPlaneEl.getAttribute('width'));
          const ph = parseFloat(photoPlaneEl.getAttribute('height'));
          const rtW = Math.floor(window.innerWidth  * 0.3);
          const rtH = Math.floor(rtW * (ph / pw));
          const renderTarget = new THREE.WebGLRenderTarget(rtW, rtH);

          // Grab the Three.js mesh for the plane
          let photoMesh = photoPlaneEl.getObject3D('mesh');
          photoPlaneEl.addEventListener('object3dset', evt => {
            if (evt.detail.type === 'mesh') {
              photoMesh = evt.detail.object3D;
            }
          });

          // On click: crop, render, read back & stamp into an HTML <img>
          this.handleCapture = () => {
            // 1) Hide HUD so it doesn't appear in the shot
            finderFrameEl.setAttribute('visible', false);
            photoPlaneEl.setAttribute('visible', false);
             // 2) Compute world & screen metrics
            const fullW = renderer.domElement.width;
            const fullH = renderer.domElement.height;
            const left  = (fullW - rtW) / 2;
            const top   = (fullH - rtH) / 2;

            // 3) “Which peeps” logic (using fullW/fullH for consistency)
            const camPos = new THREE.Vector3();
            cameraEl.getWorldPosition(camPos);
            const camDir = new THREE.Vector3();
            cameraEl.getWorldDirection(camDir);

            const captured = [];
            sceneEl.querySelectorAll('[data-peep-type]').forEach(peepEl => {
              const worldPos = new THREE.Vector3();
              peepEl.object3D.getWorldPosition(worldPos);

              // Cull behind camera
              if (camDir.dot(worldPos.clone().sub(camPos)) <= 0) return;

              // Project into the same buffer coords
              const ndc = worldPos.clone().project(cameraEl);
              const x   = (ndc.x + 1) / 2 * fullW;
              const y   = (1 - ndc.y) / 2 * fullH;

              if (x >= left && x <= left + rtW && y >= top && y <= top + rtH) {
                captured.push({
                  id:       peepEl.id,
                  type:     peepEl.dataset.peepType,
                  distance: worldPos.distanceTo(camPos)
                });
              }
            });

            // 4) Temporarily disable XR so we render monoscopic into RT
            const wasXR = renderer.xr.enabled;
            renderer.xr.enabled = false;

              // 4.1) Force camera aspect to match the RT (because of POV being wrong when VR mode is on)
              const prevAspect = cameraEl.aspect;
              cameraEl.aspect = fullW / fullH;
              cameraEl.updateProjectionMatrix();

            // 5) Do the sub-frustum render
            cameraEl.setViewOffset(fullW, fullH, left, fullH - top - rtH, rtW, rtH);
            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            renderer.render(sceneEl.object3D, cameraEl);
            renderer.setRenderTarget(null);
            cameraEl.clearViewOffset();

              // 5.1) Restore the original camera aspect
              cameraEl.aspect = prevAspect;
              cameraEl.updateProjectionMatrix();

            // 6) Restore XR mode
            renderer.xr.enabled = wasXR;

            // 7) Blit it onto the photo-plane
            if (photoMesh) {
              photoMesh.material.map         = renderTarget.texture;
              photoMesh.material.needsUpdate = true;
              photoPlaneEl.setAttribute('visible', true);
            } else {
              console.warn('photoPlane mesh not ready');
            }

            // 8) Show HUD again
            finderFrameEl.setAttribute('visible', true);
          };

          // Read the triggers for all devices
          // mouse & touch
          window.addEventListener('click',        this.handleCapture);
          // Vive/Wand/Quest remotes
          sceneEl.addEventListener('triggerdown', this.handleCapture);
          // WebXR “select” for generic controllers (and Oculus Go clickpad)
          sceneEl.addEventListener('selectstart', this.handleCapture);
           // Prepare to poll gamepad buttons 0–7 (A,B,X,Y,L1,R1,L2,R2) because nothing was working before for my Switch gamepad
            this.prevGP = {};  // track previous pressed state by button index
          },
          tick: function () {
            // Poll connected gamepads
            const gps = navigator.getGamepads && navigator.getGamepads();
            if (!gps) return;
            for (const gp of gps) {
              if (!gp || !gp.buttons) continue;
              // Only watch standard face & shoulder buttons
              [0,1,2,3,4,5,6,7].forEach(idx => {
                const btn = gp.buttons[idx];
                if (!btn) return;
                // on newly pressed
                if (btn.pressed && !this.prevGP[idx]) {
                  this.handleCapture();
                }
                // save for next frame
                this.prevGP[idx] = btn.pressed;
              });
            }
        }
      });

      /**
       * PEEP-MOVER COMPONENT
       * Moves the peep randomly in the XZ plane, bounces back when leaving radius, and flips entity horizontally based on movement direction.
       * Moderately chatGPT assisted.
       */
      AFRAME.registerComponent('peep-mover', {
        schema: {
          speed:  { type: 'number', default: PEEP_DEFAULT_SPEED },
          radius: { type: 'number', default: PEEP_SPAWN_RADIUS }
        },
        init: function () {
          // Initialize a random movement direction
          this.direction = Math.random() * 2 * Math.PI;
        },
        tick: function (time, delta) {
          const pos     = this.el.object3D.position;
          const prevPos = pos.clone(); // this is needed to make sure peeps face the correct direction
          // Move in direction, scaled by delta
          const moveAmt = this.data.speed * (delta / 16);
          const dx      = Math.cos(this.direction) * moveAmt;
          const dz      = Math.sin(this.direction) * moveAmt;
          pos.x += dx;
          pos.z += dz;

          // Bouce at boundaries
          const r = this.data.radius;
          if (pos.x > r) {
            pos.x = r;
            this.direction = Math.PI - this.direction;
          }
          if (pos.x < -r) {
            pos.x = -r;
            this.direction = Math.PI - this.direction;
          }
          if (pos.z > r) {
            pos.z = r;
            this.direction = -this.direction;
          }
          if (pos.z < -r) {
            pos.z = -r;
            this.direction = -this.direction;
          }

          this.el.object3D.position.copy(pos);

          // — NEW FLIP LOGIC, heavily chatGPT assisted — project both positions to camera NDC
          const cam     = this.el.sceneEl.camera;
          const ndcPrev = prevPos.clone().project(cam);
          const ndcCurr = pos.clone().project(cam);
          // if it moved right on screen, keep scale=1; otherwise flip
          let flip;
          if (ndcCurr.x > ndcPrev.x) {
              flip = 1;
          } else {
              flip = -1;
          }
          this.el.setAttribute('scale', `${flip} 1 1`);
        }
      });

      /**
       * BILLBOARD COMPONENT
       * Rotates the entity around the Y axis so its front face always faces the camera, keeping the sprite upright on the XZ plane.
       * Heavily chatGPT assisted, it fixed my 'look-at-y' component that was not working properly
       */
      AFRAME.registerComponent('billboard', {
        tick: function () {
          const camera  = this.el.sceneEl.camera;
          const obj     = this.el.object3D;
          // Get world positions
          const camPos  = new THREE.Vector3();
          camera.getWorldPosition(camPos);
          const pos     = obj.position;

          // Compute angle on XZ plane and set Y rotation
          const dx = camPos.x - obj.position.x;
          const dz = camPos.z - obj.position.z;
          const angle = Math.atan2(dx, dz);
          const deg   = THREE.MathUtils.radToDeg(angle);
          this.el.setAttribute('rotation', { x: 0, y: deg, z: 0 });
        }
      });

      /**
       * NO-FRUSTUM-CULLL COMPONENT
       * Disables frustum culling on the mesh so entities don't vanish when out of view bounds
       * Fully chatGPT generated, I have no idea how this works, that's how it fixed the peeps disappearing out of bounds
       */
       AFRAME.registerComponent('no-frustum-cull', {
          init: function () {
            this.el.addEventListener('loaded', () => {
              this.el.object3D.traverse(node => {
                if (node.isMesh) node.frustumCulled = false;
              });
            });
          }
        });

      /**
       * PEEP-MANAGER COMPONENT
       * Spawns a number of peeps, with tags, id and data-peep-type, and attaches mover + billboard + no-frustum-cull.
       * chatGPT assisted
       */
       AFRAME.registerComponent('peep-manager', {
        schema: {
          count:        { type: 'int',    default: PEEP_SPAWN_COUNT },
          radius:       { type: 'number', default: PEEP_SPAWN_RADIUS },
          assetPrefix:  { type: 'string', default: '#' }
        },
        init: function () {
          const half = this.data.count / 2;
          for (let i = 0; i < this.data.count; i++) {
            let type;
            if (i < half) {
              type = 'circle';
            } else {
              type = 'square';
            }

            let spriteId;
            if (type === 'circle') {
              spriteId = 'circleNeutralPeep';
            } else {
              spriteId = 'squareNeutralPeep';
            }

            const peepEl = document.createElement('a-image');

            // Unique ID and type tag, this is used to know what peeps are in front of the camera
            peepEl.setAttribute('id', `${type}-${i}`);
            peepEl.setAttribute('data-peep-type', type);

            // Random XZ within radius, Y = 1
            const angle   = Math.random() * 2 * Math.PI;
            const dist    = Math.random() * this.data.radius;
            const x = dist * Math.cos(angle);
            const z = dist * Math.sin(angle);
            peepEl.setAttribute('position', `${x} 1 ${z}`);
            peepEl.setAttribute('src', this.data.assetPrefix + spriteId);

             // Prevents png invisible parts collision
            peepEl.setAttribute('material', 'transparent: true; alphaTest: 0.01');

            // Add behaviors
            peepEl.setAttribute('billboard', '');
            peepEl.setAttribute(
              'peep-mover',
              `speed: ${0.01 + Math.random() * 0.01}; radius: ${
                this.data.radius
              }`
            );
            peepEl.setAttribute('no-frustum-cull', '');

            // --- DEBUG: Floating ID label over each peep - chatGPT generated ---
            const labelEl = document.createElement('a-entity');
            labelEl.classList.add('debug-label');
            labelEl.setAttribute('text',
              `value: ${peepEl.id}; align: center; width: 2; color: #000`);
            labelEl.setAttribute('position', '0 0.5 0');   // slightly above the head
            labelEl.setAttribute('billboard', '');         // always face camera
            labelEl.setAttribute('visible', false);        // start hidden
            peepEl.appendChild(labelEl);
            // ----------------------------------------------

            this.el.appendChild(peepEl);
          }
        }
      });
    </script>
  </head>

  <body>
    <a-scene debug-toggle fog="type: linear; color: #D3D3D3; near: 20; far: 100">
      <!-- Assets -->
      <a-assets>
        <img id = "ground"            src = "sprites/ground.png" />
        <img id = "camFrame"          src = "sprites/cam/cam.png" />
        <img id = "circleNeutralPeep" src = "sprites/peeps/placeholder/circle_neutral_peep.png" />
        <img id = "squareNeutralPeep" src = "sprites/peeps/placeholder/square_neutral_peep.png" />
      </a-assets>

      <!-- Player camera -->
      <a-entity
        id        = "playerCamera"
        camera    = "near:0.1; far:500"
        look-controls = "
            pointerLockEnabled:         true;
            magicWindowTrackingEnabled: true;
            mouseEnabled:               true;
            touchEnabled:               true;
            "
        camera-tracker
        photo-capture
        position  = "0 1.6 0"
       >
        <!-- the fixed “viewfinder” frame -->
        <a-plane
          id        = "finderFrame"
          src       = "#camFrame"
          width     = "0.4"
          height    = "0.5"
          position  = "0 0 -0.6"
          material  = "transparent: true; alphaTest: 0.01"
          animation = "property: position; dur: 2000; dir: alternate; loop: true; to: 0.01 0.01 -0.6; easing: easeInOutQuad"
        ></a-plane>

        <!-- the freeze-frame, initially hidden -->
        <a-plane
          id        = "photoPlane"
          visible   = "false"
          width     = "0.4"
          height    = "0.5"
          position  = "0 0 -0.6"
          material  = "shader: flat; transparent: true; side: double"
        ></a-plane>
      </a-entity>

      <!-- Infinite ground plane -->
      <a-plane
        src       = "#ground"
        rotation  = "-90 0 0"
        width     = "200"
        height    = "200"
        material  = "repeat: 40 40; side: double">
      </a-plane>

      <!-- Sky background -->
      <a-sky color="#D3D3D3"></a-sky>

      <!-- Peep spawner -->
      <a-entity
        id        = "peeps"
        peep-manager
      ></a-entity>
    </a-scene>
  </body>
</html>