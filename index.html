<!DOCTYPE html>
<html>
  <head>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="js/textStrings.js"></script>

    <script>
      // GENERAL VALUES
      const PEEP_SPAWN_COUNT    = 12;
      const PEEP_SPAWN_RADIUS   = 8;
      const PEEP_DEFAULT_SPEED  = 0.015;
      const DISMISS_TIME        = 5000; //ms
      let   dismissTime         = DISMISS_TIME;
      const AUTO_DISMISS_TIME   = 15000;//ms

      const bodyHeight = 1.6; // universal world unit tall
      const bodyWidth  = (120 / 140) * bodyHeight;

      let Act   = 1;
      let Stage = "Stage_Start";

      function getRandomInt(max) {
        return Math.floor(Math.random() * max);
      }

      /**
       * SPRITESHEET-ANIMATION COMPONENT
       * This is a costum component that helps incorporating spritesheet suppport into A-Frame
       * heavily chatGPT assisted, based on this: https://stackoverflow.com/questions/51620935/aframe-spritesheet-component-freezing-webvr-environment-in-browser, since I had no idea how to do this. I was going to create a single image for every frame and change them manually in code
       */
      AFRAME.registerComponent('spritesheet-animation', {
        schema: {
          rows:            { type: 'number', default: 1 },
          columns:         { type: 'number', default: 1 },
          firstFrameIndex: { type: 'number', default: 0 },
          lastFrameIndex:  { type: 'number', default: -1 },
          frameDuration:   { type: 'number', default: 0.1 }, // seconds
          loop:            { type: 'boolean', default: true }
        },

        init: function () {
          const d = this.data;
          this.repeatX = 1 / d.columns;
          this.repeatY = 1 / d.rows;
          if (d.lastFrameIndex < 0) {
            d.lastFrameIndex = d.rows * d.columns - 1;
          }
          this.currentFrameIndex = d.firstFrameIndex;
          this.frameTimer = 0;
          this.mesh = this.el.getObject3D('mesh');
        },

        tick: function (time, dt) {
          const d = this.data;
          if (!this.mesh || (!d.loop && this.currentFrameIndex > d.lastFrameIndex)) return;

          this.frameTimer += dt / 1000;
          while (this.frameTimer > d.frameDuration) {
            this.currentFrameIndex++;
            this.frameTimer -= d.frameDuration;
            if (this.currentFrameIndex > d.lastFrameIndex) {
              if (d.loop) {
                this.currentFrameIndex = d.firstFrameIndex;
              } else {
                return;
              }
            }
          }

          const col = this.currentFrameIndex % d.columns;
          const row = Math.floor(this.currentFrameIndex / d.columns);
          const offsetX = col / d.columns;
          const offsetY = (d.rows - row - 1) / d.rows;

          if (this.mesh.material.map) {
          this.mesh.material.map.repeat.set(this.repeatX, this.repeatY);
          this.mesh.material.map.offset.set(offsetX, offsetY);
        }
        }
      });

       /**
       * DEBUG-TOGGLE COMPONENT
       * I use this to create dev tools for testing
       * chatGPT assisted
       */
      AFRAME.registerComponent('debug-toggle', { // chatGPT assisted
        init: function () {
          window.DEBUG = false;

          function allDEBUGS() {
            window.DEBUG = !window.DEBUG;
              updateLabels(window.DEBUG);
              if (window.DEBUG) {
                dismissTime = 10
              } else {
                dismissTime = DISMISS_TIME;
              }
              console.log('Debug mode:', window.DEBUG ? 'ON' : 'OFF');
          }

          // peep id labels
          const updateLabels = show => {
            document.querySelectorAll('.debug-label')
              .forEach(el => el.setAttribute('visible', show));
          };

          // Toggle on “D” key
          window.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'd') {
              allDEBUGS();
            }
          });

          // Toggle on gamepad D-pad Up (standard button index 12)
          this.upPressed = false;
          this.tick = () => {
            const gps = navigator.getGamepads && navigator.getGamepads();
            if (!gps) return;
            for (const gp of gps) {
              if (!gp || !gp.buttons[12]) continue;
              const btn = gp.buttons[12];
              if (btn.pressed && !this.upPressed) {
                allDEBUGS();
                this.upPressed = true;
              } else if (!btn.pressed) {
                this.upPressed = false;
              }
            }
          };
        }
      });

      /**
       * GAME-MANAGER COMPONENT
       * Controls the most complex element that happen in each Act, then called in GAME LOGIC part of the photo-capture component
       * Lightly chatGPT assisted, mostly helping me porting the Act_I.js original file
       */
      AFRAME.registerComponent('game-manager', {
        init: function () {
          const sceneEl   = this.el.sceneEl;

          // listen for our “spawn” moments
          sceneEl.addEventListener('spawn-lovers' , () => this.spawnLovers());
          sceneEl.addEventListener('spawn-crazy'  , () => this.spawnCrazy());

          if (Act == 1 && Stage == "Stage_Start") {
            spawnNeutralPeeps(PEEP_SPAWN_COUNT);
            // after 5s, spawn the Hat Guy
            setTimeout(() => {
              Stage = "Stage_Hat";

              const camObj    = sceneEl.camera;
              const worldPos  = new THREE.Vector3();
              camObj.getWorldPosition(worldPos);
              const camDir    = new THREE.Vector3();
              camObj.getWorldDirection(camDir);

              // place him 3 units behind the camera
              const spawnPos = worldPos.clone().add(camDir.multiplyScalar(-3));

              // create the a-image for Hat Peep
              const hatGuy = document.createElement('a-image');
              hatGuy.setAttribute('id', 'hat_guy-0');
              hatGuy.setAttribute('data-peep-type', 'hat_guy');
              hatGuy.setAttribute('src', '#hatguySheet');
              hatGuy.setAttribute('width',  bodyWidth);
              hatGuy.setAttribute('height', bodyHeight);
              hatGuy.setAttribute('spritesheet-animation', {
                columns:          1,
                rows:             1,
                firstFrameIndex:  0,
                lastFrameIndex:   0,
                frameDuration:    1,
                loop:             false
              });
              hatGuy.setAttribute('position', `${spawnPos.x} ${bodyHeight/2} ${spawnPos.z}`);

              // standard behaviors
              hatGuy.setAttribute('billboard', '');
              hatGuy.setAttribute('peep-mover', `speed : 0.01; radius : 8`);
              hatGuy.setAttribute('peep-flipper', '');
              hatGuy.setAttribute('no-frustum-cull', '');
              hatGuy.setAttribute('material', 'transparent: true; alphaTest: 0.01');

              sceneEl.appendChild(hatGuy);

              console.log("hat spawned");
            }, 2000);
          } else {
            return;
          }
        },

        spawnLovers: function () {
          const sceneEl = this.el.sceneEl;
          const cam     = sceneEl.camera;
          // get a point 3 units behind the camera
          const camPos  = new THREE.Vector3();
          cam.getWorldPosition(camPos);
          const camDir  = new THREE.Vector3();
          cam.getWorldDirection(camDir);
          const basePos = camPos.clone().add(camDir.multiplyScalar(-3));

          // helper to build a lover peep
          function makeLover(type, idSuffix, xOffset) {
            const peepEl = document.createElement('a-entity');
            peepEl.setAttribute('id', `lover-${type}-${idSuffix}`);
            peepEl.setAttribute('data-peep-type', `lover_${type}`);
            peepEl.setAttribute('mood', 'inLove');
            peepEl.setAttribute('position',`${basePos.x + xOffset} ${bodyHeight/2} ${basePos.z}`);
            // body
            const body = document.createElement('a-image');
            body.setAttribute('src',   '#bodySheet');
            body.setAttribute('width',  bodyWidth);
            body.setAttribute('height', bodyHeight);
            body.setAttribute('spritesheet-animation', {
              columns:          2,
              rows:             1,
              firstFrameIndex:  type === 'circle' ? 0 : 1,
              lastFrameIndex:   type === 'circle' ? 0 : 1,
              frameDuration:    1,
              loop:             false
            });
            body.setAttribute('material', 'transparent:true;alphaTest:0.01');
            peepEl.appendChild(body);

            // shirt overlay
            const shirt = document.createElement('a-image');
            shirt.setAttribute('src',   '#lover_shirtSheet');
            shirt.setAttribute('width',  bodyWidth);
            shirt.setAttribute('height', bodyHeight);
            shirt.setAttribute('spritesheet-animation', {
              columns:          2,
              rows:             1,
              firstFrameIndex:  type === 'circle' ? 0 : 1,
              lastFrameIndex:   type === 'circle' ? 0 : 1,
              frameDuration:    1,
              loop:             false
            });
            shirt.setAttribute('material', 'transparent:true;alphaTest:0.01');
            peepEl.appendChild(shirt);

            // face (frame 8)
            const face = document.createElement('a-image');
            face.setAttribute('src',   '#faceSheet');
            face.setAttribute('width',  bodyWidth);
            face.setAttribute('height', bodyHeight);
            face.setAttribute('spritesheet-animation', {
              columns:          2,
              rows:             7,
              firstFrameIndex:  8, // kawai face
              lastFrameIndex:   8,
              frameDuration:    0.5,
              loop:             false
            });
            face.setAttribute('position', '0.03 -0.25 0.01');
            face.setAttribute('material', 'transparent:true;alphaTest:0.01');
            peepEl.appendChild(face);

            // little love-hat above head
            const lovehat = document.createElement('a-image');
            lovehat.setAttribute('src',   '#lovehatSheet');
            lovehat.setAttribute('width',  bodyWidth * 0.5);
            lovehat.setAttribute('height', bodyHeight * 0.5);
            lovehat.setAttribute('position', `0 0.27 0`);
            lovehat.setAttribute('material', 'transparent:true;alphaTest:0.01');
            peepEl.appendChild(lovehat);

            // common extras
            peepEl.setAttribute('billboard',      '');
            peepEl.setAttribute('no-frustum-cull', '');
            return peepEl;
          }

          // 3a) circle: normal random mover
          const circle = makeLover('circle', 0, -bodyWidth*0.5);
          circle.setAttribute('peep-mover', '');
          circle.setAttribute('peep-flipper', '');
          sceneEl.appendChild(circle);
          console.log("circle lover spawned");

          // 3b) square: follow the circle
          const square = makeLover('square', 0, +bodyWidth*0.5);
          // remove its random mover if any, then add follow-target
          square.components['peep-mover'] && square.removeAttribute('peep-mover');
          square.setAttribute('follow-target', `target:#lover-circle-0; speed:${PEEP_DEFAULT_SPEED}`);
          sceneEl.appendChild(square);
          console.log("square lover spawned");
        },

        spawnCrazy: function () {
          const sceneEl = this.el.sceneEl;
          const cam     = sceneEl.camera;
          const camPos  = new THREE.Vector3();
          cam.getWorldPosition(camPos);
          const camDir  = new THREE.Vector3();
          cam.getWorldDirection(camDir);

          // 3 units behind camera
          const basePos = camPos.clone().add(camDir.multiplyScalar(-3));

          const crazyEl = document.createElement('a-entity');
          crazyEl.setAttribute('id', 'crazy-0');
          crazyEl.setAttribute('data-peep-type', 'crazy');
          crazyEl.setAttribute('mood', 'crazy');
          crazyEl.setAttribute('position', `${basePos.x} ${bodyHeight/2} ${basePos.z}`);

          const crazyBody = document.createElement('a-image');
          crazyBody.setAttribute('src', '#crazySheet');
          crazyBody.setAttribute('width', bodyWidth + 0.2);
          crazyBody.setAttribute('height', bodyHeight);
          crazyBody.setAttribute('spritesheet-animation', {
            columns:          3,
            rows:             7,
            firstFrameIndex:  0,
            lastFrameIndex:   9,
            frameDuration:    0.1,
            loop:             true
          });
          crazyBody.setAttribute('material', 'transparent:true;alphaTest:0.01');
          crazyEl.appendChild(crazyBody);

          crazyEl.setAttribute('billboard',      '');
          crazyEl.setAttribute('peep-mover',     '');
          crazyEl.setAttribute('peep-flipper',   '');
          crazyEl.setAttribute('no-frustum-cull','');
          crazyEl.setAttribute('crazy-behavior', '');

          sceneEl.appendChild(crazyEl);
          console.log('crazy spawned');
        },
      });

      /**
       * PHOTO-CAPTURE COMPONENT
       * Grabs a snippet of the canva in GPU and shows it on click
       * heavily chatGPT assisted for all the calculations and screenshot related code, but after lots of guidance and research on StackOverflow to finally come to this https://stackoverflow.com/questions/19183180/how-to-save-an-image-to-localstorage-and-display-it-on-the-next-page
       * the game logic that is also found in this snippet of code was coded purely by human me
       */
      AFRAME.registerComponent('photo-capture', {
        init: function () {
          const sceneEl    = this.el.sceneEl;
          const renderer   = sceneEl.renderer;
          // Grab the *entity* camera (always the monoscopic one), not the scene’s XR ArrayCamera.
          const cameraEl   = this.el.getObject3D('camera');

          const finderFrameEl     = sceneEl.querySelector('#finderFrame');
          const pointAndClickEl   = sceneEl.querySelector('#initialTooltip');

          const captureHUDel      = sceneEl.querySelector('#captureHUD')
          const photoPlaneEl      = sceneEl.querySelector('#photoPlane');
          const phoneEl           = sceneEl.querySelector('#phonePlane');
          
          const captionContainer  = sceneEl.querySelector('#captionContainer');
          const captionBox        = sceneEl.querySelector('#captionBox');
          const captionEl         = sceneEl.querySelector('#photoCaption');
          const hashtagPlane      = sceneEl.querySelector('#hashtagPlane');

          pointAndClickEl.setAttribute('text', `value: ${textStrings_EN["pointAndClick"]}`);

          this.enableDismissTimer = null;
          this.autoDismissTimer   = null;

          // Function to set the different attributes of the capture in one go
          function updateCaption(key, isInteresting = false) {
            // 1) set the text
            captionEl.setAttribute('text', `value: ${textStrings_EN[key]}`);
            // 2) tint the box
            captionBox.setAttribute('color',
              isInteresting ? '#cc2727' : '#000000'
            );
            // 3) pick which hashtag image
            hashtagPlane.setAttribute('src',
            isInteresting ? '#hashtag' : '#hashtagBroken'
            );
            // 4) show the whole container
            captionContainer.setAttribute('visible', true);
          }

          // We'll now defer RT sizing until we know the current buffer size (VR or desktop hopefully)
          const pw = parseFloat(photoPlaneEl.getAttribute('width'));
          const ph = parseFloat(photoPlaneEl.getAttribute('height'));
          let renderTarget;

          // Grab the Three.js mesh once it’s loaded
          let photoMesh = photoPlaneEl.getObject3D('mesh');
          photoPlaneEl.addEventListener('object3dset', evt => {
            if (evt.detail.type === 'mesh') {
              photoMesh = evt.detail.object3D;
            }
          });

          // State flags
          this.hasCaptured   = false;
          this.dismissActive = false;

          // Clears the freeze-frame UI and stops listening for dismiss
          this.clearCapture = () => {
            // 1) stop any pending timers so they can't double-fire
            clearTimeout(this.enableDismissTimer);
            clearTimeout(this.autoDismissTimer);

            // 2) emit the end-animation event
            this.el.sceneEl.emit('end-capture-animation');

            // 3) restore your HUD
            captureHUDel .setAttribute('visible', false);
            finderFrameEl.setAttribute('visible', true);

            // 4) cleanup the dismiss listeners
            window   .removeEventListener('click'      , this.handleDismiss);
            sceneEl  .removeEventListener('triggerdown', this.handleDismiss);
            sceneEl  .removeEventListener('selectstart', this.handleDismiss);

            // 5) reset flags
            this.hasCaptured   = false;
            this.dismissActive = false;

            // 6) Re-attach your capture listeners so the next click works**
            window   .addEventListener('click'      , this.handleCapture);
            sceneEl  .addEventListener('triggerdown', this.handleCapture);
            sceneEl  .addEventListener('selectstart', this.handleCapture);
          };
            
          // Called on first click to do the actual capture
          this.handleCapture = () => {
            if (this.hasCaptured) return;
            this.hasCaptured = true;

            // Remove the tooltip after the first click
            pointAndClickEl.setAttribute('visible', false);

            // hide HUD so it doesn't show in the shot
            finderFrameEl .setAttribute('visible', false);
            captureHUDel  .setAttribute('visible', false);

            // Which peeps are in frame? (NEW : replace CSS based to renderer based, don't understand exactly what's going on here, but it's supposed to work on VR now)
            const fullW = renderer.domElement.width;
            const fullH = renderer.domElement.height;
            // I) detection region: exactly trial and error again of buffer... ugh this is taking longer than I would want it to --> this is because the capture IDs and photo taken is not the same crop level for some reason
            const detectFraction = 0.42;
            const detW           = Math.floor(fullW * detectFraction);
            const detH           = Math.floor(detW * (ph / pw));
            const detLeft        = Math.floor((fullW - detW) / 2);
            const detTop         = Math.floor((fullH - detH) / 2);

            const camPos = new THREE.Vector3();
            cameraEl.getWorldPosition(camPos);
            const camDir = new THREE.Vector3();
            cameraEl.getWorldDirection(camDir);

            const captured = [];
            sceneEl.querySelectorAll('[data-peep-type]').forEach(peepEl => {
              const worldPos = new THREE.Vector3();
              peepEl.object3D.getWorldPosition(worldPos);

              // Cull behind camera
              if (camDir.dot(worldPos.clone().sub(camPos)) <= 0) return;

              // Project into the same buffer coords
              const ndc = worldPos.clone().project(cameraEl);
              const x   = (ndc.x + 1) / 2 * fullW;
              const y   = (1 - ndc.y) / 2 * fullH;
              if (x >= detLeft && x <= detLeft + detW &&
                  y >= detTop  && y <= detTop  + detH) { // II) do your hit-testing against detLeft, detTop, detW, detH
                captured.push({
                  el:       peepEl,
                  id:       peepEl.id,
                  type:     peepEl.dataset.peepType,
                  mood:     peepEl.getAttribute('mood'),
                  distance: worldPos.distanceTo(camPos),
                  xPosition: x,
                });
              }
            });
            // store results
            this.capturedPeeps        = captured;
            window.lastCapturedPeeps  = captured;
            console.log('Captured peeps:', captured);
            //console.log('Captured peep IDs:', captured.map(peep => peep.id));

            // Detect any phones in the shot
            const capturedPhones = [];
            sceneEl.querySelectorAll('.capture-phone').forEach(phoneEl => {
              const worldPos = new THREE.Vector3();
              phoneEl.object3D.getWorldPosition(worldPos);

              // Cull phones behind the camera
              if (camDir.dot(worldPos.clone().sub(camPos)) <= 0) return;

              // Project into the same buffer coords
              const ndc = worldPos.clone().project(cameraEl);
              const x   = (ndc.x + 1) / 2 * fullW;
              const y   = (1 - ndc.y) / 2 * fullH;

              if (x >= detLeft && x <= detLeft + detW &&
                  y >= detTop  && y <= detTop  + detH) { // II) do your hit-testing against detLeft, detTop, detW, detH
                capturedPhones.push(phoneEl);
              }
            });

            // III) now for rendering, shrink to "number" --> trial and error
            const displayFraction = 0.2;
            const rtW             = Math.floor(fullW  * displayFraction);
            const rtH             = Math.floor(rtW    * (ph / pw));
            const left            = Math.floor((fullW - rtW) / 2);
            const top             = Math.floor((fullH - rtH) / 2);

            renderTarget          = new THREE.WebGLRenderTarget(rtW, rtH);

            // Temporarily disable XR for a monoscopic render into our new RT
            const wasXR = renderer.xr.enabled;
            renderer.xr.enabled = false;

            // Force camera aspect to match RT (because of POV being wrong when VR mode is on)
            const prevAspect  = cameraEl.aspect;
            cameraEl.aspect   = fullW / fullH;
            cameraEl.updateProjectionMatrix();

            // Render exactly that sub-region
            cameraEl.setViewOffset(
              fullW, fullH,
              left,  fullH - top - rtH,
              rtW,   rtH
            );
            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            renderer.render(sceneEl.object3D, cameraEl);
            renderer.setRenderTarget(null);
            cameraEl.clearViewOffset();

            // Restore original camera aspect & XR
            cameraEl.aaspect = prevAspect;
            cameraEl.updateProjectionMatrix();
            renderer.xr.enabled = wasXR;

            // 4) Swap that RT texture into your photoMesh
            if (photoMesh) {
              photoMesh.material.map         = renderTarget.texture;
              photoMesh.material.needsUpdate = true;
            } else {
              console.warn('photoPlane mesh not ready');
            }

          ////////////////////////////////////////////////////////////////////////////////
          ////////////////////////////////////////////////////////////////////////////////
          ////////////////////////////////////////////////////////////////////////////////
          ////░██████╗░░█████╗░███╗░░░███╗███████╗//██╗░░░░░░█████╗░░██████╗░██╗░█████╗░//
          ////██╔════╝░██╔══██╗████╗░████║██╔════╝//██║░░░░░██╔══██╗██╔════╝░██║██╔══██╗//
          ////██║░░██╗░███████║██╔████╔██║█████╗░░//██║░░░░░██║░░██║██║░░██╗░██║██║░░╚═╝//
          ////██║░░╚██╗██╔══██║██║╚██╔╝██║██╔══╝░░//██║░░░░░██║░░██║██║░░╚██╗██║██║░░██╗//
          ////╚██████╔╝██║░░██║██║░╚═╝░██║███████╗//███████╗╚█████╔╝╚██████╔╝██║╚█████╔╝//
          ////░╚═════╝░╚═╝░░╚═╝╚═╝░░░░░╚═╝╚══════╝//╚══════╝░╚════╝░░╚═════╝░╚═╝░╚════╝░//
          ////////////////////////////////////////////////////////////////////////////////
          ////////////////////////////////////////////////////////////////////////////////
          ////////////////////////////////////////////////////////////////////////////////

            // NOTHING
            if (captured.length === 0 && capturedPhones.length === 0) {
              updateCaption('wowNothing');
              this.el.sceneEl.emit('start-capture-animation');

            // ACT 1
            // Hat Guy
            } else if (Act == 1 && Stage == "Stage_Hat" && captured.some(p => p.type === 'hat_guy')) {
              const capturedHatGuy = captured.find(p => p.type === 'hat_guy'); // find the correct peep
              // see if any other captured peep “blocks” it
              const someoneInFront = captured.some(p => {
                return p.id !== capturedHatGuy.id
                    && Math.abs(p.xPosition - capturedHatGuy.xPosition) < 40
                    && p.distance < capturedHatGuy.distance;
              });
              if (someoneInFront) {
                updateCaption('subjectHidden');
                this.el.sceneEl.emit('start-capture-animation');

              } else {
                updateCaption('niceHat', true);
                this.el.sceneEl.emit('start-capture-animation');
                  
                const sceneEl = this.el.sceneEl;

                // Remove the hat-guy
                const hatGuy = sceneEl.querySelector('#hat_guy-0');
                if (hatGuy) hatGuy.remove(); console.log("hat guy executed");

                // Pick six random normal peeps
                let normals = Array.from(sceneEl.querySelectorAll('[data-peep-type]')).filter(el => el.dataset.peepType !== 'hat_guy');
                normals.sort(() => 0.5 - Math.random());
                const chosen = normals.slice(0, 6);

                // For each, attach a hat, set mood, swap face
                chosen.forEach(peepEl => {
                  // Hat sprite
                  const hat = document.createElement('a-image');
                  hat.setAttribute('src',    '#hatSheet');
                  hat.setAttribute('width',   bodyWidth * 0.8);
                  hat.setAttribute('position', `0 0.185 0.01`);
                  hat.setAttribute('spritesheet-animation', {
                    columns:          4,
                    rows:             7,
                    firstFrameIndex:  0,
                    lastFrameIndex:   14,
                    frameDuration:    0.1,
                    loop:             false
                  });
                  hat.setAttribute('material', 'transparent:true;alphaTest:0.01');
                  peepEl.appendChild(hat);

                  // Mood
                  peepEl.setAttribute('mood', 'hatted');

                  // Couldn't just swap the face for some reason, so instead I just replace it to the "proud" face (frame 6)
                  peepEl.removeChild(peepEl.querySelector('a-image[src="#faceSheet"]'));
                  const face = document.createElement('a-image');
                  face.setAttribute('src',   '#faceSheet');
                  face.setAttribute('width',  bodyWidth);
                  face.setAttribute('height', bodyHeight);
                  face.setAttribute('position', `0.04 -0.15 0.01`);
                  face.setAttribute('spritesheet-animation', {
                    columns:         2,
                    rows:            7,
                    firstFrameIndex: 6,
                    lastFrameIndex:  6,
                    frameDuration:   0.5,
                    loop:            true,
                  });
                  // Prevents png invisible parts collision
                  face.setAttribute('material', 'transparent: true; alphaTest: 0.01');
                  peepEl.appendChild(face);
                });

                Stage = "Stage_Lovers";
                this.el.sceneEl.emit('spawn-lovers');
              }

            // Crazy screamer
            } else if (captured.some(p => p.type === 'crazy') || captured.some(p => p.mood === 'spooked')) {
              if (captured.some(p => p.type === 'crazy')) {
                const capturedCrazy = captured.find(p => p.type === 'crazy'); // find the correct peep
                const crazyEl       = capturedCrazy.el;

                if (captured.some(p => p.mood === 'spooked')) {
                  updateCaption('crazySquareAttacks', true);
                  this.el.sceneEl.emit('start-capture-animation');

                  if (crazyEl.parentNode) crazyEl.parentNode.removeChild(crazyEl); console.log(crazyEl.id + " executed");

                  Stage = "Stage_Nervous";
                  
                } else {
                  updateCaption('somethingInteresting');
                  this.el.sceneEl.emit('start-capture-animation');
                }
              } else {
                updateCaption('whoIsScreaming');
                this.el.sceneEl.emit('start-capture-animation');
              }

            // Lovers (all acts and stages)
            } else if (captured.some(p => p.type === 'lover_circle') && captured.some(p => p.type === 'lover_square')) {
              const capturedCircleLover = captured.find(p => p.type === 'lover_circle'); // find the correct peeps
              const circEl              = capturedCircleLover.el;
              const capturedSquareLover = captured.find(p => p.type === 'lover_square');
              const sqrEl               = capturedSquareLover.el;

              [circEl, sqrEl].forEach(peepEl => {
                const face = peepEl.querySelector('a-image[src="#faceSheet"]');
                const mood = peepEl.getAttribute('mood');

                if (mood === 'inLove') {
                  updateCaption('getARoom', true);
                  this.el.sceneEl.emit('start-capture-animation');

                  face.setAttribute('position', `0.07 -0.25 0.01`);
                  face.setAttribute('spritesheet-animation', {
                    columns:          2,
                    rows:             7,
                    firstFrameIndex:  9, // humiliated face
                    lastFrameIndex:   9,
                    frameDuration:    0.5,
                    loop:             true
                  });

                  peepEl.setAttribute('mood', 'embarassed');

                  // 1) kill their random mover
                  peepEl.removeAttribute('peep-mover');

                  // 2) compute an “exit” target a bit to camera’s right & far away in Z
                  const camPos = new THREE.Vector3();
                  this.el.sceneEl.camera.getWorldPosition(camPos);
                  const exitX = camPos.x + 13;
                  const exitZ = camPos.z - 30;
                  const exitY = bodyHeight / 2;

                  // 3) animate them moving off
                  peepEl.setAttribute('animation__runoff', {
                    property: 'position',
                    to:       `${exitX} ${exitY} ${exitZ}`,
                    dur:      10000,
                    easing:   'linear',
                  });

                  // 4) once that’s done, remove them
                  peepEl.addEventListener('animationcomplete__runoff', () => {
                    if (peepEl.parentNode) peepEl.parentNode.removeChild(peepEl); console.log(peepEl.id + " executed");
                  }, { once: true });

                  if (Stage == 'Stage_Lovers') {
                    Act     = 2;
                    Stage   = 'Stage_Screamer'
                    spawnNeutralPeeps(4);
                    this.el.sceneEl.emit('spawn-crazy');
                  }

                } else {
                  updateCaption('outtaHere');
                  this.el.sceneEl.emit('start-capture-animation');

                  face.setAttribute('spritesheet-animation', {
                    columns:          2,
                    rows:             7,
                    firstFrameIndex:  10,
                    lastFrameIndex:   10,
                    frameDuration:    0.1,
                    loop:             true
                  });
                  peepEl.setAttribute('mood', 'escaping');

                }
              });

            // Hatted Peep (all acts and stages)
            } else if (captured.some(p => p.mood === 'hatted')) {
              updateCaption('notCoolAnymore');
              this.el.sceneEl.emit('start-capture-animation');

              captured.filter(p => p.mood === 'hatted').forEach(p => {
                const peepEl  = p.el;
                const face    = peepEl.querySelector('a-image[src="#faceSheet"]');
                const hat     = peepEl.querySelector('a-image[src="#hatSheet"]');

                // Couldn't just swap the face for some reason, so instead I just replace it to the "neutral" face
                peepEl.removeChild(face);
                const embarassedFace = document.createElement('a-image');
                embarassedFace.setAttribute('src',   '#faceSheet');
                embarassedFace.setAttribute('width',  bodyWidth);
                embarassedFace.setAttribute('height', bodyHeight);
                embarassedFace.setAttribute('scale',    '0.8 0.8 1');
                embarassedFace.setAttribute('position', `0.04 -0.2 0.01`)
                embarassedFace.setAttribute('spritesheet-animation', {
                  columns:          2,
                  rows:             7,
                  firstFrameIndex:  7,  // embarassed face
                  lastFrameIndex:   7,
                  frameDuration:    0.5,
                  loop:             true
                });
                // Prevents png invisible parts collision
                embarassedFace.setAttribute('material', 'transparent: true; alphaTest: 0.01');
                peepEl.appendChild(embarassedFace);

                setTimeout(() => {
                  hat.setAttribute('spritesheet-animation', {
                    columns:          4,
                    rows:             7,
                    firstFrameIndex:  14,
                    lastFrameIndex:   25,
                    frameDuration:    0.1,
                    loop:             false
                  });
                }, 1000);

                setTimeout(() => {
                  // Couldn't just swap the face for some reason, so instead I just replace it to the "neutral" face
                  peepEl.removeChild(embarassedFace);
                  const newFace = document.createElement('a-image');
                  newFace.setAttribute('src',   '#faceSheet');
                  newFace.setAttribute('width',  bodyWidth);
                  newFace.setAttribute('height', bodyHeight);
                  newFace.setAttribute('position', `0.04 0 0.01`);
                  newFace.setAttribute('spritesheet-animation', {
                    columns:          2,
                    rows:             7,
                    firstFrameIndex:  0, // neutral face
                    lastFrameIndex:   0,
                    frameDuration:    3,
                    loop:             true
                  });
                  // Prevents png invisible parts collision
                  newFace.setAttribute('material', 'transparent: true; alphaTest: 0.01');
                  peepEl.appendChild(newFace);
                  peepEl.removeChild(hat);
                }, 5000);

                  peepEl.setAttribute('mood', 'neutral');

              });

            // DEFAULT
            // Phone on phone
            } else if (capturedPhones.length > 0) {
              updateCaption('phoneOnPhone');
              this.el.sceneEl.emit('start-capture-animation');
            // A single normal peep
            } else if (captured.length === 1) {
              updateCaption('normalPeep');
              this.el.sceneEl.emit('start-capture-animation');
            } else {
            // A few normal peeps
              updateCaption('normalPeeps');
              this.el.sceneEl.emit('start-capture-animation');
            }

            ////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////

            // Show HUD again and make peeps look at their phones as well
            captureHUDel.setAttribute('visible', true);
            
            // Schedule un‐skippable interval & auto-dismiss
            this.enableDismissTimer = setTimeout(() => {
              this.dismissActive = true;
            }, dismissTime);
            this.autoDismissTimer = setTimeout(() => {
              this.clearCapture();
            }, AUTO_DISMISS_TIME);

            // Switch from "capture" to "dismiss" listeners
            window   .removeEventListener('click'      , this.handleCapture);
            sceneEl  .removeEventListener('triggerdown', this.handleCapture);
            sceneEl  .removeEventListener('selectstart', this.handleCapture);

            window   .addEventListener('click'      , this.handleDismiss);
            sceneEl  .addEventListener('triggerdown', this.handleDismiss);
            sceneEl  .addEventListener('selectstart', this.handleDismiss);
          };

          // Called on (post-5s) click to dismiss
          this.handleDismiss = () => {
            if (!this.dismissActive) return;
            this.clearCapture();
          };

          // Read the triggers for all devices
          // mouse & touch
          window.addEventListener('click',        this.handleCapture);
          // Vive/Wand/Quest remotes
          sceneEl.addEventListener('triggerdown', this.handleCapture);
          // WebXR “select” for generic controllers (and Oculus Go clickpad) --> heavily chatGPT assisted, because I couldn't find any other solution
          sceneEl.addEventListener('selectstart', this.handleCapture);
          // Prepare to poll gamepad buttons 0–7 (A,B,X,Y,L1,R1,L2,R2) because nothing was working before for my Switch gamepad
          this.prevGP = {};  // track previous pressed state by button index
        },
        tick: function () {
            // Poll connected gamepads
          const gps = navigator.getGamepads && navigator.getGamepads();
          if (!gps) return;
          for (const gp of gps) {
            if (!gp || !gp.buttons) continue;
            [0,1,2,3,4,5,6,7].forEach(idx => {
              const btn = gp.buttons[idx];
              if (!btn) return;
                // on newly pressed
              if (btn.pressed && !this.prevGP[idx]) {
                if (!this.hasCaptured) {
                  this.handleCapture();
                } else if (this.dismissActive) {
                  this.handleDismiss();
                }
              }
              // save for next frame
              this.prevGP[idx] = btn.pressed;
            });
          }
        }
      });

      /**
       * PEEP-MOVER COMPONENT
       * Moves the peep randomly in the XZ plane, bounces back when leaving radius.
       * Moderately chatGPT assisted.
       */
      AFRAME.registerComponent('peep-mover', {
        schema: {
          speed:  { type: 'number', default: PEEP_DEFAULT_SPEED },
          radius: { type: 'number', default: PEEP_SPAWN_RADIUS }
        },
        init: function () {
          // Initialize a random movement direction
          this.direction = Math.random() * 2 * Math.PI;
        },
        tick: function (time, delta) {
          if (!this.data) return; // safeguard when the screamed at and screamer peeps get removed and put back the peep mover
          const pos     = this.el.object3D.position;
          const prevPos = pos.clone(); // this is needed to make sure peeps face the correct direction
          // Move in direction, scaled by delta
          const moveAmt = this.data.speed * (delta / 16); // BUG: This sometimes breaks here when used for the screamer peep, need to check what to do here
          const dx      = Math.cos(this.direction) * moveAmt;
          const dz      = Math.sin(this.direction) * moveAmt;
          pos.x += dx;
          pos.z += dz;

          // Bouce at boundaries
          const r = this.data.radius;
          if (pos.x > r) {
            pos.x = r;
            this.direction = Math.PI - this.direction;
          }
          if (pos.x < -r) {
            pos.x = -r;
            this.direction = Math.PI - this.direction;
          }
          if (pos.z > r) {
            pos.z = r;
            this.direction = -this.direction;
          }
          if (pos.z < -r) {
            pos.z = -r;
            this.direction = -this.direction;
          }

          this.el.object3D.position.copy(pos);
        }
      });

      /**
       * PEEP-FLIPPER COMPONENT
       * Flips the entity horizontally depending on the side it's facing
       * Previously within peep-mover, let's me change remove the random peep-mover of the peeps, while keeping the flipping.
       * Copy-pasted from before
       */
      AFRAME.registerComponent('peep-flipper', {
        init: function () {
          this.prevPos = this.el.object3D.position.clone();
        },
        tick: function () {
          const pos     = this.el.object3D.position;
          const prevPos = this.prevPos;
          const cam     = this.el.sceneEl.camera;

          // project into NDC
          const ndcPrev = prevPos.clone().project(cam);
          const ndcCurr = pos.clone().project(cam);
          const flip    = ndcCurr.x > ndcPrev.x ? 1 : -1;

          // apply
          this.el.setAttribute('scale', `${flip} 1 1`);

          // store for next frame
          this.prevPos.copy(pos);
        }
      });

      /**
       * CRAZY-BEHAVIOUR COMPONENT
       * Makes the whole crazy peep behaviour and reaction to it
       * chatGPT assisted.
       */
      AFRAME.registerComponent('crazy-behavior', {
        schema: {
          screamRange:      { type: 'number', default: 2 },
          screamCooldown:   { type: 'number', default: 3000 },
          screamAnimStart:  { type: 'number', default: 10 },
          screamAnimEnd:    { type: 'number', default: 20 },
          frameDuration:    { type: 'number', default: 0.08 }
        },
        init: function () {
          this.cooldown = false;
          this.screaming = false;
          this.screamTimeout = null;
          this.screamedAt = null;
          this.bodyWidth = (120 / 180) * 1.6;
          this.bodyHeight = 1.6;
        },
        tick: function () {
          if (this.cooldown || this.screaming) return;

          // Check for the closest peep that isn't itself or already spooked
          const myPos   = this.el.object3D.position;
          const sceneEl = this.el.sceneEl;
          const peeps   = Array.from(sceneEl.querySelectorAll('[data-peep-type]'))
            .filter(el =>
              el !== this.el &&
              el.getAttribute('mood') !== 'spooked' &&
              el.getAttribute('data-peep-type') !== 'crazy'
            );

          let closest = null, closestDist = Infinity;
          peeps.forEach(peep => {
            const pos   = peep.object3D.position;
            const dist  = myPos.distanceTo(pos);
            if (dist < this.data.screamRange && dist < closestDist) {
              closest     = peep;
              closestDist = dist;
            }
          });

          if (closest) this.screamAt(closest);
        },
        screamAt: function (targetPeep) {
          this.screaming = true;
          this.screamedAt = targetPeep;
          const frameCount = this.data.screamAnimEnd - this.data.screamAnimStart + 1;
          const animDuration = frameCount * this.data.frameDuration * 1000; // ms

          // Stop crazy movement, play scream animation
          this.el.removeAttribute('peep-mover');
          this.el.removeAttribute('peep-flipper');
          const previousMood = this.el.getAttribute('mood');

          // Flip the screamer towards the screamedAt
          this.flipPeepToward(this.el, targetPeep);

          const crazyImg = this.el.querySelector('a-image');
          crazyImg.setAttribute('spritesheet-animation', {
            columns:          3,
            rows:             7,
            firstFrameIndex:  this.data.screamAnimStart,
            lastFrameIndex:   this.data.screamAnimEnd,
            frameDuration:    this.data.frameDuration,
            loop:             false
          });

          // Spook the target peep
          targetPeep.setAttribute('mood', 'spooked');
          targetPeep.removeAttribute('peep-mover');
          targetPeep.removeAttribute('peep-flipper');
          // Flip target to look at crazy
          this.flipPeepToward(targetPeep, this.el);

          // Replace face with spooked face, after a slight delay for dramatic effect
          setTimeout(() => {
            this.replaceFace(targetPeep, 3);
          }, animDuration * 0.33);

          // After animDuration (frames 10–20), crazy resumes walking (but stays in cooldown)
          setTimeout(() => {
            crazyImg.setAttribute('spritesheet-animation', {
              columns:          3,
              rows:             7,
              firstFrameIndex:  0,
              lastFrameIndex:   9,
              frameDuration:    this.data.frameDuration,
              loop:             true
            });
            this.el.setAttribute('peep-mover', '');
            this.el.setAttribute('peep-flipper', '');
            this.screaming = false;
            // Start cooldown (can't scream at new peep for a while)
            this.cooldown = true;
            setTimeout(() => { this.cooldown = false; }, this.data.screamCooldown);
          }, animDuration);

          // After 3s, reset target peep to neutral mood/face and restore mover
          setTimeout(() => {
            targetPeep.setAttribute('mood', `${previousMood}`);
            this.replaceFace(targetPeep, 0);
            targetPeep.setAttribute('peep-mover', '');
            targetPeep.setAttribute('peep-flipper', '');
          }, 3000);
        },
        // Always swap face for new one
        replaceFace: function (peepEl, frameIndex) {
          // Remove existing face (if any)
          const oldFace = peepEl.querySelector('a-image[src="#faceSheet"]');
          if (oldFace) peepEl.removeChild(oldFace);

          const bodyHeight  = this.bodyHeight;
          const bodyWidth   = this.bodyWidth;

          const newFace = document.createElement('a-image');
          newFace.setAttribute('src', '#faceSheet');
          newFace.setAttribute('width', bodyWidth);
          newFace.setAttribute('height', bodyHeight);
          newFace.setAttribute('position', `0.04 0 0.01`);
          newFace.setAttribute('spritesheet-animation', {
            columns:          2,
            rows:             7,
            firstFrameIndex:  frameIndex,
            lastFrameIndex:   frameIndex,
            frameDuration:    3,
            loop: true
          });
          newFace.setAttribute('material', 'transparent: true; alphaTest: 0.01');
          peepEl.appendChild(newFace);
        },
        flipPeepToward: function (peep, targetPos) {
          const myPos = peep.object3D.position;
          const flip = (targetPos.x > myPos.x) ? 1 : -1;
            peep.setAttribute('scale', `${flip} 1 1`);
        },
        remove: function () {
          clearTimeout(this.screamTimeout);
        }
      });

      /**
       * FOLLOW-TARGET COMPONENT
       * Permits the square lover to follow the circle lover
       * Heavily chatGPT assisted
       */
      AFRAME.registerComponent('follow-target', {
      schema: {
        target:      { type: 'selector' },
        speed:       { type: 'number', default: PEEP_DEFAULT_SPEED },
        minDistance: { type: 'number', default: 0.6 },
        tolerance:   { type: 'number', default: 0.4 }
      },

      init: function () {
        // remember last world‐position for flip logic
        this.prevPos = this.el.object3D.position.clone();
      },

      tick: function (time, delta) {
        const data   = this.data;
        const target = data.target;
        if (!target) return;

        const pos      = this.el.object3D.position;
        const worldPos = new THREE.Vector3();
        target.object3D.getWorldPosition(worldPos);

        // compute horizontal vector toward target
        const dir  = worldPos.clone().sub(pos);
        dir.y = 0;
        const dist = dir.length();
        if (dist < 1e-3) return;
        const dirNorm = dir.clone().normalize();

        // If we're too far step forward
        if (dist > data.minDistance + data.tolerance) {
          const moveAmt = data.speed * (delta / 16);
          pos.addScaledVector(dirNorm, moveAmt);
        // If we're too close snap back
        } else if (dist < data.minDistance - data.tolerance) {
          pos.copy(
            worldPos.clone().sub(dirNorm.multiplyScalar(data.minDistance))
          );
        }
        this.el.object3D.position.copy(pos);

        // Maintain whatever flip you had on-screen
        const cam     = this.el.sceneEl.camera;
        const ndcPrev = this.prevPos.clone().project(cam);
        const ndcCurr = pos.clone().project(cam);
        const flip    = ndcCurr.x > ndcPrev.x ? 1 : -1;
        this.el.setAttribute('scale', `${flip} 1 1`);
        this.prevPos.copy(pos);
      }
    });

      /**
       * BILLBOARD COMPONENT
       * Rotates the entity around the Y axis so its front face always faces the camera, keeping the sprite upright on the XZ plane.
       * Heavily chatGPT assisted, it fixed my 'look-at-y' component that was not working properly
       */
      AFRAME.registerComponent('billboard', {
        tick: function () {
          const camera  = this.el.sceneEl.camera;
          const obj     = this.el.object3D;
          // Get world positions
          const camPos  = new THREE.Vector3();
          camera.getWorldPosition(camPos);
          const pos     = obj.position;

          // Compute angle on XZ plane and set Y rotation
          const dx = camPos.x - obj.position.x;
          const dz = camPos.z - obj.position.z;
          const angle = Math.atan2(dx, dz);
          const deg   = THREE.MathUtils.radToDeg(angle);
          this.el.setAttribute('rotation', { x: 0, y: deg, z: 0 });
        }
      });

      /**
       * CAPTURE-ANIMATION COMPONENT
       * Stops the peeps from moving and make them look at their phone
       */
       AFRAME.registerComponent('capture-animation', {
        schema: {
          lookOffset:   { type: 'vec2',   default: { x: 0.04, y: -0.05 } },
          phoneSize:    { type: 'number', default: 0.3 },
          lookDuration: { type: 'number', default: 700 } // ms
        },

        init: function () {
          this.originalSpeeds       = new Map();
          this.originalFacePos      = new Map();
          this.originalMoverTicks   = new Map();
          this.originalFlipperTicks = new Map();
          this.animating            = false;

          this.el.addEventListener('start-capture-animation', () => {
            if (!this.animating) this.runStart();
          });
          this.el.addEventListener('end-capture-animation', () => {
            if (this.animating)  this.runEnd();
          });
        },

        runStart: function () {
          this.animating = true;
          const { lookOffset, phoneSize, lookDuration } = this.data;
          const peeps = Array.from(this.el.querySelectorAll('[data-peep-type]'));

          peeps.forEach(peepEl => {
            // 1a) Halt their movement
            const mover = peepEl.components['peep-mover'];
            if (mover) {
              // remember its speed
              this.originalSpeeds.set(peepEl, mover.data.speed);
              // remember its tick function
              this.originalMoverTicks.set(peepEl, mover.tick.bind(mover));
              // disable movement
              mover.tick = () => {};
              mover.data.speed = 0;
            }

            // 1b) Halt flipping
            const flipper = peepEl.components['peep-flipper'];
            if (flipper) {
              // remember its flip
              this.originalFlipperTicks.set(peepEl, flipper.tick.bind(flipper));
              flipper.tick = () => {};
            }
            // snap to whatever flip they had at the moment
            const origScale = peepEl.getAttribute('scale');
            peepEl.setAttribute('scale', origScale);

            // 2) Spawn & animate the phone popping out
            const phone = document.createElement('a-image');
            phone.setAttribute('src',    '#phone');
            phone.setAttribute('width',  phoneSize);
            phone.setAttribute('height', phoneSize);
            // start behind them
            phone.setAttribute('position', '0 -0.5 -0.001');
            phone.classList.add('capture-phone');
            // animate up into view
            phone.setAttribute('animation__phonein', `
              property: position;
              to:       0.42 -0.3 0.1;
              dur:      ${lookDuration};
              easing:   easeOutQuad;
              loop:     false
            `);
            phone.setAttribute('material', 'transparent: true; alphaTest: 0.01');
            peepEl.appendChild(phone);

            // 3) Make the face look down
            const face = peepEl.querySelector('[spritesheet-animation][src="#faceSheet"]');
            if (face) {
              const orig = face.getAttribute('position');
              this.originalFacePos.set(face, { ...orig });
              face.setAttribute('animation__lookdown', {
                property: 'position',
                to:       `${orig.x + lookOffset.x} ${orig.y + lookOffset.y} ${orig.z}`,
                dur:      lookDuration,
                easing:   'easeOutQuad',
                loop:     false
              });
            }
          });
        },

        runEnd: function () {
          const { lookDuration } = this.data;
          const peeps = Array.from(this.el.querySelectorAll('[data-peep-type]'));

          peeps.forEach(peepEl => {
            // 1) Eyes look back up
            const face = peepEl.querySelector('[animation__lookdown]');
            if (face && this.originalFacePos.has(face)) {
              const orig = this.originalFacePos.get(face);
              face.removeAttribute('animation__lookdown');
              face.setAttribute('animation__lookup', `
                property: position;
                to:       ${orig.x} ${orig.y} ${orig.z};
                dur:      ${lookDuration};
                easing:   easeOutQuad;
                loop:     false
              `);
            }

            // 2) Phone slides back
            const phone = peepEl.querySelector('.capture-phone');
            if (phone) {
              phone.removeAttribute('animation__phonein');
              phone.setAttribute('animation__phoneout', `
                property: position;
                to:       0 -0.5 -0.001;
                dur:      ${lookDuration};
                easing:   easeInQuad;
                loop:     false
              `);
            }

            // 3 After the animation finishes, restore & clean up
            setTimeout(() => {
              // 3a) restore mover speed
              const mover = peepEl.components['peep-mover'];
              if (mover && this.originalMoverTicks.has(peepEl)) {
                mover.tick = this.originalMoverTicks.get(peepEl);
                const speed = this.originalSpeeds.get(peepEl);
                peepEl.setAttribute('peep-mover', `speed: ${speed}`);
                this.originalMoverTicks.delete(peepEl);
                this.originalSpeeds.delete(peepEl);
              }
              // 3b) restore flipper
              const flipper = peepEl.components['peep-flipper'];
              if (flipper && this.originalFlipperTicks.has(peepEl)) {
                flipper.tick = this.originalFlipperTicks.get(peepEl);
                this.originalFlipperTicks.delete(peepEl);
              }
              // remove the phone entity
              if (phone && phone.parentNode) {
                peepEl.removeChild(phone);
              }
              // clean up face animation
              if (face) {
                face.removeAttribute('animation__lookup');
                this.originalFacePos.delete(face);
              }
              this.animating = false;
            }, lookDuration);
          });
        }
      });

      /**
       * NO-FRUSTUM-CULLL COMPONENT
       * Disables frustum culling on the mesh so entities don't vanish when out of view bounds
       * Fully chatGPT generated, I have no idea how this works, that's how it fixed the peeps disappearing out of bounds
       */
       AFRAME.registerComponent('no-frustum-cull', {
          init: function () {
            this.el.addEventListener('loaded', () => {
              this.el.object3D.traverse(node => {
                if (node.isMesh) node.frustumCulled = false;
              });
            });
          }
        });

      /**
       * Spawns a number of neutral peeps (half circles, half squares) in random positions.
       * Replaces the previous 'peep-manager' A-Frame component.
       * Use: spawnNeutralPeeps(count, [radius], [parentEl])
       *  - count: Number of peeps to spawn.
       *  - radius (optional)
       *  - parentEl (optional): Parent element to append to (default '#peeps').
       * 
       * chatGPT assisted
       */
      function spawnNeutralPeeps(count, radius = PEEP_SPAWN_RADIUS, parentEl = null) {
        // Use #peeps entity as default parent if not provided
        if (!parentEl) parentEl = document.querySelector('#peeps');
        
        const half = count / 2;

        for (let i = 0; i < count; i++) {
          let type;
          if (i < half) {
            type = 'circle';
          } else {
            type = 'square';
          }

          function getNextPeepIndex(type) {
            // Finds all peeps with data-peep-type=type and returns the next index
            const all = document.querySelectorAll(`[data-peep-type="${type}"]`);
            return all.length;
          }

          const index = getNextPeepIndex(type);
          const id = `${type}-${index}`;
          const initialMood = "neutral";

          // Parent container for body + face
          const peepEl = document.createElement('a-entity');
          peepEl.setAttribute('id', id);
          peepEl.setAttribute('data-peep-type', type);
          peepEl.setAttribute('mood', initialMood);

          // Random XZ within radius, Y = 0.8 (mid-body)
          const angle = Math.random() * 2 * Math.PI;
          const dist  = Math.random() * radius;
          const x     = dist * Math.cos(angle);
          const z     = dist * Math.sin(angle);
          peepEl.setAttribute('position', `${x} ${bodyHeight/2} ${z}`);

          // BODY sprite
          const body = document.createElement('a-image');
          body.setAttribute('src', '#bodySheet');
          body.setAttribute('width',  bodyWidth);
          body.setAttribute('height', bodyHeight);
          body.setAttribute('spritesheet-animation', {
            columns:          2,
            rows:             1,
            firstFrameIndex:  type === 'circle' ? 0 : 1,
            lastFrameIndex:   type === 'circle' ? 0 : 1,
            frameDuration:    1,
            loop:             false
          });
          // Prevents png invisible parts collision
          body.setAttribute('material', 'transparent: true; alphaTest: 0.01');
          peepEl.appendChild(body);

          // FACE sprite, neutral only
          const face = document.createElement('a-image');
          face.setAttribute('src',   '#faceSheet');
          face.setAttribute('width',  bodyWidth);
          face.setAttribute('height', bodyHeight);
          face.setAttribute('position', `0.04 0 0.01`);
          face.setAttribute('spritesheet-animation', {
            columns:          2,
            rows:             7,
            firstFrameIndex:  0, // neutral face
            lastFrameIndex:   0,
            frameDuration:    0.5,
            loop:             true
          });
          // Prevents png invisible parts collision
          face.setAttribute('material', 'transparent: true; alphaTest: 0.01');
          peepEl.appendChild(face);

          // Prevents png invisible parts collision
          peepEl.setAttribute('material', 'transparent: true; alphaTest: 0.01');

          // Common behavior
          peepEl.setAttribute('billboard', '');
          peepEl.setAttribute(
            'peep-mover',
            `speed: ${0.01 + Math.random() * 0.01}; radius: ${radius}`
          );
          peepEl.setAttribute('peep-flipper', '');
          peepEl.setAttribute('no-frustum-cull', '');

            // --- DEBUG: Floating ID label over each peep - chatGPT generated ---
          const labelEl = document.createElement('a-entity');
          labelEl.classList.add('debug-label');
          labelEl.setAttribute('text', `
            value: ${id};
            align: center;
            width: 2;
            color: #000
          `);
          labelEl.setAttribute('position', '0 0.6 0');
          labelEl.setAttribute('billboard', '');
          labelEl.setAttribute('visible', false);
          peepEl.appendChild(labelEl);
          // ----------------------------------------------

          parentEl.appendChild(peepEl);
          console.log("spawned " + count + " peeps!");
        }
      }

    </script>
  </head>

  <body>
    <a-scene 
      debug-toggle 
      game-manager
      capture-animation
      fog= "type: linear; color: #D3D3D3; near: 20; far: 100"
      >

      <!-- Assets -->
      <a-assets>
        <img id = "ground"            src = "sprites/ground.png" />
        <img id = "camFrame"          src = "sprites/cam/cam.png" />
        <img id = "phone"             src = "sprites/phone.png" />
        <img id = "hashtag"           src = "sprites/hashtag.png" />
        <img id = "hashtagBroken"     src = "sprites/hashtag_broken.png" />

        <img id = "bodySheet"         src = "sprites/peeps/body.png" />
        <img id = "crazySheet"        src = "sprites/peeps/hangry.png" />
        <img if = "redBodySheet"      src = "sprites/peeps/body_red.png" />
        <img id = "faceSheet"         src = "sprites/peeps/face.png" />
        <img id = "angryFaceSheet"    src = "sprites/peeps/face_angry.png" />
        <img id = "hatguySheet"       src = "sprites/peeps/hatguy.png" />
        <img id = "lover_shirtSheet"  src = "sprites/peeps/lover_shirt.png" />
        <img id = "lovehatSheet"      src = "sprites/peeps/lovehat.png" />

        <img id = "hatSheet"          src = "sprites/peeps/hat.png" />
      </a-assets>

      <!-- Player camera -->
      <a-entity
        id        = "playerCamera"
        camera    = "near:0.1; far:500"
        look-controls = "
            pointerLockEnabled:         true;
            magicWindowTrackingEnabled: true;
            mouseEnabled:               true;
            touchEnabled:               true;
            "
        camera-tracker
        photo-capture
        position  = "0 1.6 0"
       >
        <!-- the fixed “viewfinder” frame -->
        <a-plane
          id        = "finderFrame"
          src       = "#camFrame"
          width     = "0.4"
          height    = "0.5"
          position  = "0 0 -0.62"
          material  = "transparent: true; alphaTest: 0.01"
          animation = "property: position; dur: 2000; dir: alternate; loop: true; to: 0.01 0.01 -0.62; easing: easeInOutQuad"
          >
          <a-entity
            id        = "initialTooltip"
            position  = "0 -0.3 0"
            scale     = "3 3 1"
            text      = "
              value : ;
              align : center;
              font  : exo2bold;
              width : 0.4;
              color : #000000;
              baseline: center;
          ">
          </a-entity>
        </a-plane>

        <a-entity 
          id        = "captureHUD"
          position  = "0 0 -0.6"
          visible   = "false"
          >
          <!-- the freeze-frame, initially hidden -->
          <a-plane
            id        = "photoPlane"
            width     = "0.4"
            height    = "0.5"
            position  = "0 0 0"
            material  = "shader: flat; transparent: true; side: double"
          ></a-plane>

          <a-plane
            id        = "phonePlane"
            src       = "#phone"
            height    = "0.88"
            position  = "0 -0.07 -0.01"
            material  = "shader: flat; transparent: true; alphaTest: 0.01; side: double"
          ></a-plane>

          <!-- Caption container -->
          <a-entity id = "captionContainer" position = "0 -0.32 0">
            
            <!-- Background box -->
            <a-plane
              id        = "captionBox"
              width     = "0.4"
              height    = "0.13"
              color     = "#000000"
              material  = "transparent: true; opacity: 1"
            ></a-plane>

            <!-- Wrapped, left-aligned text -->
            <a-entity
              id        = "photoCaption"
              position  = "-0.17 0 0.001"
              scale     = "1.4 1.4 1"
              text      = "
                value: ;
                font: exo2bold;
                align: left;
                anchor: left;
                width: 0.4;
                color: #ffffff;
                baseline: center;
              "
            ></a-entity>

            <!-- Hashtag from the original chypron -->
            <a-plane
              id        = "hashtagPlane"
              src       = "#hashtagBroken"
              position  = "-0.18 0.06 0.001"
              scale     = "0.07 0.07 0"
              material  = "shader: flat; transparent: true; alphaTest: 0.01; side: double"
            ></a-plane>
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Infinite ground plane -->
      <a-plane
        src       = "#ground"
        rotation  = "-90 0 0"
        width     = "200"
        height    = "200"
        material  = "repeat: 40 40; side: double">
      </a-plane>

      <!-- Sky background -->
      <a-sky color  = "#D3D3D3"></a-sky>

      <!-- Peep spawner -->
      <a-entity
        id        = "peeps"
      ></a-entity>
    </a-scene>
  </body>
</html>